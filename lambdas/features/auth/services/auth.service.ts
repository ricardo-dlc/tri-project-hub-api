/**
 * Authentication service layer
 * Implements sign up, sign in, sign out, session validation and refresh functionality
 * Requirements: 1.1, 1.3, 1.4, 2.1, 2.2, 3.4
 */

import { sessionRepository } from '../models/session.model';
import { userRepository } from '../models/user.model';
import { type SafeUser } from '../../../shared/auth/schema';
import {
  type AuthResult,
  type Session,
  type SessionValidationResult,
  type SignInRequest,
  type SignUpRequest,
  type User,
  type UserRole,
} from '../types/auth.types';
import {
  validateSessionToken,
  validateSignInRequest,
  validateSignUpRequest,
} from '../types/validation.schemas';

/**
 * Authentication error classes
 */
export class AuthenticationError extends Error {
  constructor(message: string, public code: string = 'AUTH_FAILED') {
    super(message);
    this.name = 'AuthenticationError';
  }
}

export class ValidationError extends Error {
  constructor(message: string, public code: string = 'VALIDATION_ERROR') {
    super(message);
    this.name = 'ValidationError';
  }
}

export class UserExistsError extends Error {
  constructor(message: string, public code: string = 'USER_EXISTS') {
    super(message);
    this.name = 'UserExistsError';
  }
}

export class SessionExpiredError extends Error {
  constructor(message: string, public code: string = 'SESSION_EXPIRED') {
    super(message);
    this.name = 'SessionExpiredError';
  }
}

/**
 * Password strength validation result
 */
export interface PasswordStrengthResult {
  isValid: boolean;
  score: number; // 0-4 (weak to strong)
  feedback: string[];
}

/**
 * Authentication service class
 * Provides high-level authentication operations using Better-Auth and custom repositories
 */
export class AuthService {
  /**
   * User registration with email and password
   * Requirements: 1.1, 1.3, 1.4
   */
  async signUp(signUpData: SignUpRequest): Promise<AuthResult> {
    try {
      // Validate input data
      const validatedData = validateSignUpRequest(signUpData);
      console.log('validatedData:', validatedData);

      // Additional password strength validation
      const passwordStrength = this.validatePasswordStrength(validatedData.password);
      if (!passwordStrength.isValid) {
        throw new ValidationError(
          `Password is too weak: ${passwordStrength.feedback.join(', ')}`
        );
      }

      // Check if user already exists
      const existingUser = await userRepository.getUserByEmail(validatedData.email);
      if (existingUser) {
        throw new UserExistsError('User with this email already exists');
      }

      // Create user using our repository (handles password hashing properly)
      // We use our own repository instead of Better-Auth's signUpEmail to ensure
      // proper password hashing with bcrypt and full control over user creation
      const createdUser = await userRepository.createUser({
        email: validatedData.email,
        password: validatedData.password,
        name: validatedData.name,
        role: 'user',
      });

      // Create a session for the new user
      // The session repository will generate a secure token and handle expiration
      const session = await sessionRepository.createSession({
        userId: createdUser.id,
        expiresIn: 7 * 24 * 60 * 60 * 1000, // 7 days in milliseconds
      });

      return {
        user: this.safeUserToUser(createdUser),
        session,
        token: session.sessionToken, // Use the token generated by the repository
      };
    } catch (error) {
      console.error('Registration error:', error);
      if (error instanceof ValidationError ||
        error instanceof UserExistsError ||
        error instanceof AuthenticationError) {
        throw error;
      }

      // Handle Better-Auth specific errors
      if (error && typeof error === 'object' && 'message' in error) {
        throw new AuthenticationError(error.message as string);
      }

      throw new AuthenticationError('Registration failed');
    }
  }

  /**
   * User authentication with email and password
   * Requirements: 2.1, 2.2
   */
  async signIn(signInData: SignInRequest): Promise<AuthResult> {
    try {
      // Validate input data
      const validatedData = validateSignInRequest(signInData);

      // Verify user credentials using our repository
      const verificationResult = await userRepository.verifyPassword(
        validatedData.email,
        validatedData.password
      );

      if (!verificationResult.isValid || !verificationResult.user) {
        throw new AuthenticationError('Invalid email or password');
      }

      // Create session using repository (it will generate a secure token)
      const session = await sessionRepository.createSession({
        userId: verificationResult.user.id,
        expiresIn: 7 * 24 * 60 * 60 * 1000, // 7 days in milliseconds
      });

      return {
        user: this.safeUserToUser(verificationResult.user),
        session,
        token: session.sessionToken,
      };
    } catch (error) {
      if (error instanceof AuthenticationError) {
        throw error;
      }

      throw new AuthenticationError('Authentication failed');
    }
  }

  /**
   * User sign out and session invalidation
   * Requirements: 2.1, 3.4
   */
  async signOut(sessionToken: string): Promise<void> {
    try {
      // Validate session token format
      validateSessionToken(sessionToken);

      // Remove session from our repository
      await sessionRepository.deleteSessionByToken(sessionToken);
    } catch (error) {
      // Log error but don't throw - sign out should be idempotent
      console.warn('Sign out warning:', error instanceof Error ? error.message : 'Unknown error');
    }
  }

  /**
   * Validate session token and return user/session data
   * Requirements: 3.4
   */
  async validateSession(sessionToken: string): Promise<SessionValidationResult> {
    try {
      // Validate session token format
      validateSessionToken(sessionToken);

      // Use session repository's validation method
      const validationResult = await sessionRepository.validateSession(sessionToken);

      if (!validationResult.valid) {
        return {
          valid: false,
          error: validationResult.error || 'Invalid session'
        };
      }

      return {
        valid: true,
        user: validationResult.user, // User object from session repository
        session: validationResult.session
      };
    } catch (error) {
      return {
        valid: false,
        error: error instanceof Error ? error.message : 'Session validation failed'
      };
    }
  }

  /**
   * Refresh session if needed and return updated session
   * Requirements: 3.4
   */
  async refreshSession(sessionToken: string): Promise<AuthResult | null> {
    try {
      // Validate session token format
      validateSessionToken(sessionToken);

      // Check current session validity
      const validation = await this.validateSession(sessionToken);
      if (!validation.valid || !validation.session || !validation.user) {
        return null;
      }

      // Check if session needs refresh (within 24 hours of expiry)
      const session = validation.session;
      const timeUntilExpiry = session.expires.getTime() - Date.now();
      const refreshThreshold = 24 * 60 * 60 * 1000; // 24 hours

      if (timeUntilExpiry > refreshThreshold) {
        // Session doesn't need refresh yet
        return {
          user: validation.user,
          session: session,
          token: sessionToken
        };
      }

      // Refresh session using repository
      const refreshedSession = await sessionRepository.refreshSessionIfNeeded(sessionToken);
      if (!refreshedSession) {
        return null;
      }

      return {
        user: validation.user,
        session: refreshedSession,
        token: refreshedSession.sessionToken
      };
    } catch (error) {
      console.warn('Session refresh warning:', error instanceof Error ? error.message : 'Unknown error');
      return null;
    }
  }

  /**
   * Validate password strength with detailed feedback
   * Requirements: 1.4, 2.2
   */
  validatePasswordStrength(password: string): PasswordStrengthResult {
    const feedback: string[] = [];
    let score = 0;

    if (!password || typeof password !== 'string') {
      return {
        isValid: false,
        score: 0,
        feedback: ['Password is required']
      };
    }

    // Length check
    if (password.length < 8) {
      feedback.push('Password must be at least 8 characters long');
    } else if (password.length >= 8) {
      score += 1;
    }

    if (password.length > 128) {
      feedback.push('Password must not exceed 128 characters');
    }

    // Character variety checks
    const hasLowercase = /[a-z]/.test(password);
    const hasUppercase = /[A-Z]/.test(password);
    const hasNumbers = /\d/.test(password);
    const hasSpecialChars = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);

    if (!hasLowercase) {
      feedback.push('Password must contain at least one lowercase letter');
    } else {
      score += 1;
    }

    if (!hasUppercase) {
      feedback.push('Password must contain at least one uppercase letter');
    } else {
      score += 1;
    }

    if (!hasNumbers) {
      feedback.push('Password must contain at least one number');
    } else {
      score += 1;
    }

    if (!hasSpecialChars) {
      feedback.push('Password must contain at least one special character');
    } else {
      score += 1;
    }

    // Additional strength checks
    if (password.length >= 12) {
      score += 1;
    }

    // Check for common patterns
    const commonPatterns = [
      /(.)\1{2,}/, // Repeated characters
      /123456|654321|abcdef|qwerty/i, // Common sequences
      /password|admin|user|login/i, // Common words
    ];

    const hasCommonPatterns = commonPatterns.some(pattern => pattern.test(password));
    if (hasCommonPatterns) {
      feedback.push('Password contains common patterns and may be easily guessed');
      score = Math.max(0, score - 1);
    }

    const isValid = feedback.length === 0 && score >= 4;

    return {
      isValid,
      score: Math.min(score, 4),
      feedback
    };
  }

  /**
   * Get current user profile from session
   * Requirements: 3.4
   */
  async getCurrentUser(sessionToken: string): Promise<User | null> {
    const validation = await this.validateSession(sessionToken);
    return validation.valid ? validation.user || null : null;
  }

  /**
   * Check if email is available for registration
   * Requirements: 1.1
   */
  async isEmailAvailable(email: string): Promise<boolean> {
    try {
      const existingUser = await userRepository.getUserByEmail(email);
      return !existingUser;
    } catch (error) {
      // If there's an error checking, assume email is not available for safety
      return false;
    }
  }







  /**
   * Convert SafeUser (from repository) to User interface (for AuthResult)
   * Ensures proper type compatibility between database schema and API types
   */
  private safeUserToUser(safeUser: SafeUser): User {
    return {
      id: safeUser.id,
      email: safeUser.email,
      emailVerified: safeUser.emailVerified,
      name: safeUser.name,
      image: safeUser.image,
      role: safeUser.role as UserRole, // Safe cast since repository validates role
      createdAt: safeUser.createdAt,
      updatedAt: safeUser.updatedAt,
    };
  }

  /**
   * Format Better-Auth user to our User interface
   */
  private formatUser(user: any): User {
    return {
      id: user.id,
      email: user.email,
      emailVerified: user.emailVerified || false,
      name: user.name || null,
      image: user.image || null,
      role: user.role || 'user',
      createdAt: new Date(user.createdAt),
      updatedAt: new Date(user.updatedAt)
    };
  }


}

/**
 * Export singleton instance
 */
export const authService = new AuthService();